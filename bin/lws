#!/usr/bin/env node

var RUN = true;

// PACKAGES
var capitalize = require('capitalize');
var chalk = require('chalk');
var cheerio = require('cheerio');
var fs = require('fs-extra');
var path = require('path');
var Promise = require('bluebird');
var userhome = require('userhome');
var _ = require('lodash');

// PARSE ARGUMENTS
var args = require('yargs')
	.usage('\nUsage: ' + chalk.white.bold('lws ') + chalk.green('<service> ') + chalk.blue('<method> ') + chalk.yellow('[parameters]'))
	.alias('c', 'context')
	.alias('h', 'help')
	.alias('n', 'number')
	.alias('p', 'print')
	.boolean('config')
	.boolean('p')
	.boolean('x')
	.default('context', '')
	.describe('context', 'The service context to use')
	.describe('config', 'Configure liferay instance setups')
	.describe('number', 'The number of times to run the supplied method')
	.describe('print', 'Print the available arguments for the supplied methods')
	.describe('x', 'Clear the services and method names cache')
	.help('h')
	.argv;

// UTILITIES
var apiGetter = require('../lib/apiGetter');
var Method = require('../lib/Method');
var configUtil = require('../lib/utils/configUtil');
var outputUtil = require('../lib/utils/outputUtil');

// CONSTANTS
var COMPANY_ID = require('../lib/utils/configUtil').getCurrentCompanyId();
var REQUEST_LIMIT = 15;

var PATH = '/api/jsonws?contextName=' + args.context;
var CONTEXT = !!args.context ? args.context : 'portal';

// VARIABLES
var serviceMethodCachePath = path.join(userhome(), '.lws', 'cache', configUtil.getCurrentInstanceName() + '.json');

fs.ensureFileSync(serviceMethodCachePath);

var serviceMethodCache = {};

try {
	serviceMethodCache = fs.readJSONSync(serviceMethodCachePath);
}
catch(e) {}

// The calls variable is used to queue up multiple method calls for chaining
var CALLS = parseCallsFromPlainArgs(args._);

var CALL_COUNT = 0;

var SERVICE = null;
var SERVICE_IMPL = null;
var SERVICE_ID = null;
var METHOD = null;

var CACHE = {};

// Util Methods

function contains(s, p) {
	return s.indexOf(p) !== -1;
}

function lowerCaseFirstLetter(s) {
	s = s.split('');

	var first = s.shift().toLowerCase();

	s.unshift(first);

	return s.join('');
}

function getDefaultValues(service) {
	var path = '../lib/serviceConfigs/' + service;

	try {
		var serviceGetter = require(path);

		return serviceGetter();
	}
	catch(e) {}

	return null;
}

function getServiceConfig(service) {
	if (isServiceConfigExists(service)) {
		return getDefaultValues(service);
	}

	return null;
}

function getMethodConfig(service, method) {
	if (isMethodConfigExists(service, method)) {
		return getServiceConfig(service)[method];
	}

	return null;
}

function isServiceConfigExists(service) {
	return !!getDefaultValues(service);
}

function isMethodConfigExists(service, method) {
	if (isServiceConfigExists(service)) {
		return !!getServiceConfig(service)[method];
	}

	return false;
}

function parseCallsFromPlainArgs(plainArgs) {
	var calls = [];

	if (plainArgs.indexOf('$') !== -1) {
		calls = plainArgs.join(' ').split(' $ ');

		calls = _.map(calls, function(call) {
			return call.split(' ');
		});
	}
	else if (plainArgs.length) {
		calls.push(plainArgs);
	}

	return calls;
}

function setServiceAndMethodValues() {
	var currentCall = CALLS[CALL_COUNT];

	if (!!currentCall) {
		SERVICE = capitalize.words(currentCall[0]);
		SERVICE_IMPL = SERVICE + 'ServiceImpl';
		SERVICE_ID = 'apiService' + SERVICE_IMPL + 'Panel';

		if (currentCall.length > 1) {
			METHOD = currentCall[1];

			if (METHOD.indexOf('-') === -1) {
				METHOD = _.kebabCase(METHOD);
			}
		}
	}
}

function makeBasicPayloadObjectFromParams(params) {
	var payload = {};

	_.forEach(params, function(param) {
		var value = null;
		var type = param.type;

		function isNumberType(type) {
			return (contains(type, 'long') ||
					contains(type, 'int') ||
					contains(type, 'short') ||
					contains(type, 'double'));
		}

		if (contains(type, '[]') ||
			contains(type, 'util.List')) {
		}
		else if (contains(type, 'Map')) {
			value = JSON.stringify({});
		}
		else if (contains(type, 'long') ||
			contains(type, 'int') ||
			contains(type, 'short') ||
			contains(type, 'double')) {
			value = 0;
		}
		else if (contains(type, 'boolean')) {
			value = false;
		}

		if (param.name === 'end') {
			value = 1000;
		}

		payload[param.name] = value;
	});

	return payload;
}

function printParameters(methodObject) {
	var requiredParams = [];
	var hasDefaultValueParams = [];

	var methodConfig = getMethodConfig(SERVICE, METHOD);

	if (!!methodConfig) {
		if (methodConfig.params) {
			hasDefaultValueParams = _.keys(methodConfig.params);
		}

		if (methodConfig.requiredParams && methodConfig.requiredParams.length) {
			requiredParams = methodConfig.requiredParams;
		}
	}

	_.forEach(methodObject.parameters, function(parameter) {
		var additionalMessage = '';

		if (hasDefaultValueParams.indexOf(parameter.name) !== -1) {
			additionalMessage = chalk.green(' (default value configured)');
		}

		if (requiredParams.indexOf(parameter.name) !== -1) {
			additionalMessage = chalk.red(' (required)');
		}

		console.log(chalk.yellow(parameter.name), ': ', chalk.blue(parameter.type), additionalMessage);
	});
}

function addDefaultValuesFromConfig(defaultValues, currentValues) {
	if (!_.isEmpty(defaultValues)) {
		_.forEach(defaultValues, function(value, key) {
			if (currentValues.hasOwnProperty(key)) {
				currentValues[key] = value;
			}
		});
	}

	return currentValues;
}

function testRequiredParams(requiredParams, userParams, cacheParams) {
	var unfulfilled = _.difference(requiredParams, userParams);
	unfulfilled = _.difference(unfulfilled, cacheParams);

	if (unfulfilled.length) {
		console.log('Required parameters not provided: ');

		_.forEach(unfulfilled, function(parameter) {
			console.log('parameter: ', parameter);
		});

		throw new Error();
	}

	return false;
}

function addValuesFromCache(cache, requiredParams, currentValues) {
	_.forEach(requiredParams, function(requiredParam) {
		if (!!cache[requiredParam]) {
			currentValues[requiredParam] = cache[requiredParam];
		}
	});

	return currentValues;
}

function addValuesFromUserArgs(userArgs, methodParameters, currentValues) {
	_.forEach(userArgs, function(value, key) {
		if (currentValues.hasOwnProperty(key)) {
			currentValues[key] = value;

			// If the parameter type is an array, assemble an array
			_.forEach(methodParameters, function(parameter) {
				if (parameter.name === key && contains(parameter.type, '[]')) {
					var arr = [];

					arr.push(value);

					currentValues[key] = JSON.stringify(arr);
				}
			});
		}
	});

	return currentValues;
}

function updateServiceMethodCache() {
	fs.writeJSONSync(serviceMethodCachePath, serviceMethodCache);
}

function getServicesListFromServiceMethodCache() {
	return _.get(serviceMethodCache, [CONTEXT, 'services'], []);
}

function getServiceMethodsListFromServiceMethodCache() {
	return _.get(serviceMethodCache, [CONTEXT, 'methods', SERVICE], []);
}

// Begin Getting...

function getServicesListFromHTML(html) {
	var $ = cheerio.load(html);

	services = _.trim($('.panel-heading .title-text').text()).split('  ');

	return services;
}

function getServiceMethodsListFromHTML(html) {
	var $ = cheerio.load(html);

	var serviceBlock = $('#' + SERVICE_ID);

	var methodLinks = [];

	if (serviceBlock.length) {
		methodLinks = _.trim($(serviceBlock).find('.lfr-api-signature .method-name').text()).split('  ');
	}

	return methodLinks;
}

function cacheServicesList(servicesList) {
	_.set(serviceMethodCache, [CONTEXT, 'services'], servicesList);

	updateServiceMethodCache();
}

function cacheServiceMethodsList(serviceMethodsList) {
	_.set(serviceMethodCache, [CONTEXT, 'methods', SERVICE], serviceMethodsList);

	updateServiceMethodCache();
}

function getServicesList(html) {
	var servicesList = getServicesListFromServiceMethodCache();

	if (!servicesList.length && !!html) {
		servicesList = getServicesListFromHTML(html);

		cacheServicesList(servicesList);
	}

	return servicesList;
}

function getServiceMethodsList(html) {
	var serviceMethodsList = getServiceMethodsListFromServiceMethodCache();

	if (!serviceMethodsList.length && !!html) {
		serviceMethodsList = getServiceMethodsListFromHTML(html);

		cacheServiceMethodsList(serviceMethodsList);
	}

	return serviceMethodsList;
}

function listServices(html) {
	var services = getServicesList(html);

	console.log('');
	console.log('Available Services:');
	_.forEach(services, function(service) {
		console.log(service);
	});
	console.log('');
}

function listServiceMethods(html) {
	var methodLinks = getServiceMethodsList(html);

	if (methodLinks.length) {
		console.log('');
		console.log('Available Methods for ' + SERVICE + ': (Names in ' + chalk.green.bold('green') +' are ready to use)');

		_.forEach(methodLinks, function(methodLink) {
			if (isMethodConfigExists(SERVICE, methodLink)) {
				console.log(chalk.green.bold(methodLink));
			}
			else {
				console.log(methodLink);
			}
		});
		console.log('');
	}
}

function getMethodPageHTML(html) {
	// Get link to method page
	var $ = cheerio.load(html);

	var serviceBlock = $('#' + SERVICE_ID);

	if (serviceBlock.length) {
		var methodLinks = $(serviceBlock).find('.lfr-api-signature .method-name');

		var methodAnchorTag = _.filter(methodLinks, function(link) {
			return _.trim($(link).text()) === METHOD;
		})[0];

		if (!!methodAnchorTag) {
			var methodURL = $(methodAnchorTag).attr('href');

			// return the html of the method page
			return apiGetter(methodURL);
		}
		else {
			throw new Error('No method found...');
		}

	}
	else {
		throw new Error('No service found...');
	}
}

function getMethodObjectFromMethodPageHTML(html) {
	// Scrape method parameters from html
	var $ = cheerio.load(html);

	var paramsHTML = $('.lfr-api-parameters .lfr-api-param');

	var params = _.map(paramsHTML, function(param) {
		param = $(param);

		var name = _.trim(param.find('.lfr-api-param-name').text());
		var type = _.trim(param.find('.lfr-api-param-type').text());

		return {
			name: name,
			type: type
		};
	});

	params = _.reject(params, function(param) {
		return (param.name === 'p_auth' ||
				param.name === 'serviceContext');
	});

	var methodObject = {
		name: METHOD,
		parameters: params,
		path: $('.lfr-api-method > h2').text(),
		service: SERVICE
	};

	return methodObject;
}

function prepareJobs(methodObject) {
	// Prepares payload object with minimal values
	var payloadTemplate = makeBasicPayloadObjectFromParams(methodObject.parameters);

	// Sets current companyId
	if (payloadTemplate.hasOwnProperty('companyId')) {
		payloadTemplate.companyId = COMPANY_ID;
	}

	// Using a jobs array and Promise.map is in preparation for
	// calling a command multiple times (e.g. adding 20 users)
	var jobs = [];
	var numberOfIterations = (args.n && typeof args.n === 'number') ? args.n : 1;

	while(numberOfIterations) {
		// Adds default values from method configuration
		var payload = _.extend({}, payloadTemplate);

		var methodConfig = getMethodConfig(methodObject.service, methodObject.name);

		if (!!methodConfig) {
			// Adds default values from config file
			payload = addDefaultValuesFromConfig(methodConfig.params, payload);

			var requiredParams = methodConfig.requiredParams;

			if (requiredParams.length) {
				testRequiredParams(requiredParams, _.keys(args), _.keys(CACHE));

				// Adds values from previously chained calls
				payload = addValuesFromCache(CACHE, requiredParams, payload);
			}
		}

		// Adds user's values from command-line arguments
		payload = addValuesFromUserArgs(args, methodObject.parameters, payload);

		// Creates the Method object with the api path and prepared
		// payload object

		jobs.push(new Method(methodObject.path, payload));

		numberOfIterations--;
	}

	args.n = 1;

	return jobs;
}

function callAPI(jobs) {
	return Promise.map(jobs, function(method) {
		return method.invoke()
			.then(function(result) {
				if (result === undefined) {
					console.log('');
					console.log('Payload object sent to server:');
					console.log(method.payload);
				}
				else {
					return result;
				}
			});
	}, { concurrency: REQUEST_LIMIT });
}

function displayAndCacheResults(results) {
	// The results should be an array
	if (_.isArray(results[0])) {
		results = results[0];
	}

	var cacheIds = [];
	var displayKeys = null;
	var displayValues = [];

	var methodOmitFromResultsDisplayKeys = [];

	var methodConfig = getMethodConfig(SERVICE, METHOD);

	if (!!methodConfig) {
		methodOmitFromResultsDisplayKeys = methodConfig.omitFromResultsDisplayKeys;
	}

	_.forEach(results, function(result) {
		if (result !== undefined) {
			console.log('');

			if (!_.isEmpty(result)) {
				// Removes columns according to method config's omitted keys
				// array.
				result = _.omit(result, function(value, key) {
					return methodOmitFromResultsDisplayKeys.indexOf(key) !== -1;
				});

				if (!displayKeys) {
					displayKeys = _.keys(result);
				}

				// Replaces any null values with an empty string
				var values = _.values(result);

				values = _.map(values, function(value) {
					return !!value ? value : '';
				});

				displayValues.push(values);

				var cacheIdKey = lowerCaseFirstLetter(SERVICE) + 'Id';

				var resultEntityId = result[cacheIdKey];

				// Set single id
				CACHE[cacheIdKey] = resultEntityId;

				// Push to ids array
				cacheIds.push(resultEntityId);
			}
		}
	});

	outputUtil.printTable(displayKeys, displayValues);

	if (!_.isEmpty(cacheIds)) {
		CACHE[lowerCaseFirstLetter(SERVICE) + 'Ids'] = JSON.stringify(cacheIds);
	}

	CALL_COUNT++;

	if (CALLS[CALL_COUNT] !== undefined) {
		setServiceAndMethodValues();

		callCurrentJob();
	}
}

function callCurrentJob() {
	return apiGetter(PATH)
		.then(getMethodPageHTML)
		.then(getMethodObjectFromMethodPageHTML)
		.then(prepareJobs)
		.then(callAPI)
		.then(displayAndCacheResults)
		.catch(function(e) {});
}

setServiceAndMethodValues();

if (RUN) {
	if (args.config) {
		require('./config');
	}
	if (args.x) {
		fs.writeJSONSync(serviceMethodCachePath, {});
	}
	else if (METHOD !== null) {
		if (args.p) {
			apiGetter(PATH)
				.then(getMethodPageHTML)
				.then(getMethodObjectFromMethodPageHTML)
				.then(printParameters);
		}
		else {
			// This is the actual api call
			callCurrentJob();
		}
	}
	else if (SERVICE_ID !== null) {
		apiGetter(PATH)
			.then(listServiceMethods);
	}
	else {
		apiGetter(PATH)
			.then(listServices);
	}
}

function startAutoComplete(services, serviceMethods) {
	var omelette = require("omelette");
	var complete = omelette("lws <service> <serviceMethod>");

	complete.on('service', function() {
		complete.reply(_.map(services, lowerCaseFirstLetter));
	});

	complete.on('serviceMethod', function(service) {
		complete.reply(serviceMethods);
	});

	complete.init();
}

if (process.argv.indexOf('--compgen') !== -1) {
	if (process.argv.indexOf('2')  !== -1) {
		var servicesList = getServicesList();

		if (servicesList.length) {
			startAutoComplete(servicesList, []);
		}
		else {
			apiGetter(PATH)
				.then(getServicesList)
				.then(function(services) {
					startAutoComplete(services, []);
				});
		}

	}
	else if (process.argv.indexOf('3')  !== -1) {
		var serviceMethodsList = getServiceMethodsList();

		if (serviceMethodsList.length) {
			startAutoComplete([], serviceMethodsList);
		}
		else {
			apiGetter(PATH)
				.then(getServiceMethodsList)
				.then(function(serviceMethods) {
					startAutoComplete([], serviceMethods);
				});
		}
	}
}

